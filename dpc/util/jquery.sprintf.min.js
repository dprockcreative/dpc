/**
#  Copyright (c) 2007 Herve Masson                                                       |
#  Version: 1.0.0
#  This product is distributed under a BSD license
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#     1. Redistributions of source code must retain the above copyright
#        notice, this list of conditions and the following disclaimer.
#     2. Redistributions in binary form must reproduce the above copyright
#        notice, this list of conditions and the following disclaimer in
#        the documentation and/or other materials provided with the
#        distribution.
#  THIS SOFTWARE IS PROVIDED BY THE MINDSTEP CORP PROJECT ``AS IS'' AND
#  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
#  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
#  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MINDSTEP CORP OR CONTRIBUTORS
#  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
#  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
#  OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
#  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
#  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
#  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#  The views and conclusions contained in the software and documentation
#  are those of the authors and should not be interpreted as representing
#  official policies, either expressed or implied, of MindStep Corp.
# @author: Herve Masson
# @version: 1.0.0 (8/27/2007)
# @requires jQuery v1.1.2 or later
*/
!function ($) { $.sprintf = function (fmt) { return _sprintf_(fmt,arguments,1); }; $.vsprintf = function (args,offset) { if (offset === undefined) { offset = 0; } return _sprintf_(args[offset],args,offset +1); }; $.alertf = function () { return alert($.vsprintf(arguments)); }; $.vlogf = function (args) { if ("console" in window) { console.info($.vsprintf(args)); } }; $.verrorf = function (args) { if ("console" in window) { console.error($.vsprintf(args)); } }; $.errorf = function () { $.verrorf(arguments); }; $.logf = function () { $.vlogf(arguments); }; FREGEXP = /^([^%]*)%(\([\w.]+\))?([-+])?(0)?(\d+)?(\.(\d+))?([doxXcsf])(.*)$/; HDIGITS = ["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"]; function _empty(str) { if (str === undefined || str === null) { return true; } return (str == "") ? true : false; } function _int_(val) { return Math.floor(val); } function _printf_num_(val,base,pad,sign,width) { val = parseInt(val,10); if (isNaN(val)) { return "NaN"; };var aval = (val<0)?-val:val; var ret = ""; if (aval == 0) { ret = "0"; } else { while(aval>0) { ret = HDIGITS[aval%base] + ret; aval = _int_(aval/base); } } if (val<0) { ret = "-" +ret; } if (sign == "-") { pad = " "; } return _printf_str_(ret,pad,sign,width,-1); } function _printf_float_(val,base,pad,sign,prec) { if (prec == undefined) { if (parseInt(val) != val) { return "" +val; } prec = 5; } var p10 = Math.pow(10,prec); var ival = "" + Math.round(val*p10); var ilen = ival.length-prec; if (ilen == 0) { return "0." + ival.substr(ilen,prec); } return ival.substr(0,ilen) + "." + ival.substr(ilen,prec); } function _printf_str_(val,pad,sign,width,prec) { var npad; if (val === undefined) { return "(undefined)"; } if (val === null) { return "(null)"; } if ((npad = width-val.length)>0) { if (sign == "-") { while(npad>0) { val += pad; npad--; } } else { while(npad>0) { val = pad + val; npad--; } } } if (prec>0) { return val.substr(0,prec); } return val; } function _sprintf_(fmt,av,index) { var output = "", i,m,line,match; line = fmt.split("\n"); for(i = 0;i<line.length;i++) { if (i>0) { output += "\n"; } fmt = line[i]; while(match = FREGEXP.exec(fmt)) { var sign = "", pad = " ", name = ""; if (!_empty(match[1])) { output += match[1]; } if (!_empty(match[2])) { name = match[2]; name = name.substring(1, name.length-1); } if (!_empty(match[3])) { sign = match[3]; } if (!_empty(match[4])) { pad = "0"; } var width = match[5], prec = match[7], type = match[8]; fmt = match[9]; var val; if (name) { val = av[1]; $.each(name.split('.'), function (i, nameseg) { val = val[nameseg]; }); } else { if (index >= av.length) { output += "[missing parameter for type '" +type +"']"; continue; } val = av[index++]; } switch(type) { case "d": output += _printf_num_(val,10,pad,sign,width); break; case "o": output += _printf_num_(val,8,pad,sign,width); break; case "x": output += _printf_num_(val,16,pad,sign,width); break; case "X": output += _printf_num_(val,16,pad,sign,width).toUpperCase(); break; case "c": output += String.fromCharCode(parseInt(val,10)); break; case "s": output += _printf_str_(val,pad,sign,width,prec); break; case "f": output += _printf_float_(val,pad,sign,width,prec); break; default: output += "[unknown format '" +type +"']"; break; } } output += fmt; } return output; }}(window.jQuery || window.Zepto);


Number.prototype.currency = function (c, d, t) {
    var n = this, c = isNaN(c = Math.abs(c)) ? 2: c, d = d === undefined ? ",": d, t = t === undefined ? ".": t, s = n < 0 ? "-": "", i = parseInt(n = Math.abs(+n || 0).toFixed(c)) + "", j = (j = i.length) > 3 ? j % 3: 0;
    return s + (j ? i.substr(0, j) + t: "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2): "");
};